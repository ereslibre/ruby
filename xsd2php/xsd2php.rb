#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

##
## Copyright (C) 2010 Rafael Fernández López <ereslibre@ereslibre.es>
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

require "pp"
require "find"
require "xmlsimple"
require "fileutils"

####################################################################################################
## Globals
####################################################################################################

$VERSION = "0.1"

####################################################################################################
## General utils
####################################################################################################

def fileToString(file)
  f = File.open(file, "r")
  contents = ""
  f.each { |line|
    contents << line
  }
  f.close
  return contents
end

def writeToFile(file)
  file << yield
end

def writeHeader(file)
  writeToFile(file) { """/*
 * This class has been autogenerated by xsd2php #{$VERSION}
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

""" }
end

class Restriction

  attr_reader :base, :minLength, :maxLength, :enumeration, :pattern, :minInclusive, :maxInclusive

  def initialize(restriction)
    @base = restriction["base"]
    if @base == "token"
      @minLength = restriction["minLength"][0]["value"] if restriction.has_key?("minLength")
      @maxLength = restriction["maxLength"][0]["value"] if restriction.has_key?("maxLength")
      @length = restriction["length"][0]["value"] if restriction.has_key?("length")
      @pattern = restriction["pattern"][0]["value"] if restriction.has_key?("pattern")
    elsif @base == "unsignedShort"
      @minInclusive = restriction["minInclusive"][0]["value"] if restriction.has_key?("minInclusive")
      @maxInclusive = restriction["maxInclusive"][0]["value"] if restriction.has_key?("maxInclusive")
    elsif @base == "normalizedString"
      @minLength = restriction["minLength"][0]["value"] if restriction.has_key?("minLength")
      @maxLength = restriction["maxLength"][0]["value"] if restriction.has_key?("maxLength")      
    end
    if restriction.has_key?("enumeration")
      @enumeration = Array.new
      restriction["enumeration"].each { | value |
        @enumeration << value["value"]
      }
    end
  end

end

class SimpleType

  attr_reader :name, :restrictions

  def initialize(name, restrictions)
    @name = name
    @restrictions = Array.new
    restrictions.each { | restriction |
      @restrictions << Restriction.new(restriction)
    }
  end

end

class Element

  attr_reader :name, :type

  def initialize(name, type)
    @name = name
    @type = type
  end

end

class ComplexType

  attr_reader :name

  def initialize(name, attributes)
    @name = name
  end

end

class PHPClass

  attr_reader :className, :simpleTypes, :elements

  def initialize(destination, contents)
    @destination = destination
    @className = contents["targetNamespace"].slice(/^((.*):)*([a-zA-Z0-9_]*)/, 3).downcase.capitalize
    @simpleTypes = Hash.new
    @complexTypes = Hash.new
    @elements = Array.new
    contents.each { | key, value |
      if key == "simpleType"
        value.each { | currKey, currValue |
          @simpleTypes[currKey] = SimpleType.new(currKey, currValue["restriction"])
        }
      elsif key == "complexType"
        value.each { | currKey, currValue |
          @complexTypes[currKey] = ComplexType.new(currKey, currValue)
        }
      elsif key == "element"
        value.each { | currKey, currValue |
          @elements << Element.new(currKey, currValue["type"])
        }
      end
    }
  end

  def writeClass(phpClasses)
    file = File.new("#{@destination}/#{@className.downcase}.php", "w")
    writeToFile(file) { "<?php\n\n" }
    writeHeader(file)
    writeToFile(file) { "class #{@className}\n{\n\tprivate $query = \"\";\n\n\n" }
    writeElements(file)
    writeXMLGenerator(file)
    file.close
  end

  private

  def writeElements(file)
    @elements.each { |element|
      writeToFile(file) { "\tpublic function do#{element.name.capitalize}() {\n"  }
      writeToFile(file) { "\t}\n\n" }
    }
  end

  def writeXMLGenerator(file)
    writeToFile(file) { "\tpublic function generateXML() {\n" }
    writeToFile(file) { "\t\t$res = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\";\n" }
    writeToFile(file) { "\t\t$res += \"<epp xmlns=\\\"urn:ietf:params:xml:ns:epp-1.0\\\" " \
      "xmlns:domain=\\\"urn:ietf:params:xml:ns:domain-1.0\\\" " \
      "xmlns:es_creds=\\\"urn:red.es:xml:ns:es_creds-1.0\\\">\";\n" }
    writeToFile(file) { "\t\t$res += \"<command>\";\n" }
    writeToFile(file) { "\t\t$res += $query;\n" }
    writeToFile(file) { "\t\t$res += \"</command>\";\n" }
    writeToFile(file) { "\t\treturn $res;\n" }
    writeToFile(file) { "\t}\n" }
  end

end

####################################################################################################
## Script
####################################################################################################

if ARGV.size != 2
  puts("usage: #$0 rootXSDdirectory destinationDirectory")
  puts
  puts("\trootXSDdirectory\tThe root directory that contains all XSD files")
  puts("\tdestinationDirectory\tThe destination directory where autogenerated files will be created")
  Process.exit
end

root = ARGV[0]
destination = ARGV[1]

rootDir = File.open(root, "r")
fileList = Array.new
Find.find(rootDir) do |path|
  fileList << path if path =~ /(.+).xml$/
end
rootDir.close

FileUtils.mkdir_p(destination)

fileContents = Array.new
for file in fileList
  fileContents << XmlSimple.xml_in(file, { "KeyAttr" => "name" })
end

phpClasses = Array.new
fileContents.each { | contents |
  phpClasses << PHPClass.new(destination, contents)
}

phpClasses.each { |phpClass|
  phpClass.writeClass(phpClasses)
}

####################################################################################################
## That was all, folks !
####################################################################################################
